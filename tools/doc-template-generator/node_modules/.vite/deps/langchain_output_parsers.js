import {
  LLMChain
} from "./chunk-5INTCCEW.js";
import {
  BaseCumulativeTransformOutputParser,
  BaseLLMOutputParser,
  BaseOutputParser,
  BaseTransformOutputParser,
  CommaSeparatedListOutputParser,
  CustomListOutputParser,
  ListOutputParser,
  OutputParserException,
  StringOutputParser
} from "./chunk-XE6MPREY.js";
import "./chunk-P47HXWBN.js";
import "./chunk-ASB6OLQT.js";
import {
  PromptTemplate
} from "./chunk-ZFKM7QHO.js";
import "./chunk-VD47VQSU.js";
import "./chunk-CTROU7EM.js";
import {
  compare,
  parsePartialJson,
  zodToJsonSchema
} from "./chunk-G22Z5J4Q.js";
import {
  z
} from "./chunk-MQERWQUL.js";

// node_modules/langchain/dist/output_parsers/regex.js
var RegexParser = class extends BaseOutputParser {
  static lc_name() {
    return "RegexParser";
  }
  get lc_attributes() {
    return {
      regex: this.lc_kwargs.regex
    };
  }
  constructor(fields, outputKeys, defaultOutputKey) {
    if (typeof fields === "string" || fields instanceof RegExp) {
      fields = { regex: fields, outputKeys, defaultOutputKey };
    }
    if (fields.regex instanceof RegExp) {
      fields.regex = {
        pattern: fields.regex.source,
        flags: fields.regex.flags
      };
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "regex"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "regex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "outputKeys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "defaultOutputKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.regex = // eslint-disable-next-line no-nested-ternary
    typeof fields.regex === "string" ? new RegExp(fields.regex) : "pattern" in fields.regex ? new RegExp(fields.regex.pattern, fields.regex.flags) : fields.regex;
    this.outputKeys = fields.outputKeys;
    this.defaultOutputKey = fields.defaultOutputKey;
  }
  _type() {
    return "regex_parser";
  }
  /**
   * Parses the given text using the regex pattern and returns a dictionary
   * with the parsed output. If the regex pattern does not match the text
   * and no defaultOutputKey is provided, throws an OutputParserException.
   * @param text The text to be parsed.
   * @returns A dictionary with the parsed output.
   */
  async parse(text) {
    const match = text.match(this.regex);
    if (match) {
      return this.outputKeys.reduce((acc, key, index) => {
        acc[key] = match[index + 1];
        return acc;
      }, {});
    }
    if (this.defaultOutputKey === void 0) {
      throw new OutputParserException(`Could not parse output: ${text}`, text);
    }
    return this.outputKeys.reduce((acc, key) => {
      acc[key] = key === this.defaultOutputKey ? text : "";
      return acc;
    }, {});
  }
  /**
   * Returns a string with instructions on how the LLM output should be
   * formatted to match the regex pattern.
   * @returns A string with formatting instructions.
   */
  getFormatInstructions() {
    return `Your response should match the following regex: ${this.regex}`;
  }
};

// node_modules/langchain/dist/output_parsers/structured.js
var StructuredOutputParser = class extends BaseOutputParser {
  static lc_name() {
    return "StructuredOutputParser";
  }
  toJSON() {
    return this.toJSONNotImplemented();
  }
  constructor(schema) {
    super(schema);
    Object.defineProperty(this, "schema", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: schema
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "structured"]
    });
  }
  /**
   * Creates a new StructuredOutputParser from a Zod schema.
   * @param schema The Zod schema which the output should match
   * @returns A new instance of StructuredOutputParser.
   */
  static fromZodSchema(schema) {
    return new this(schema);
  }
  /**
   * Creates a new StructuredOutputParser from a set of names and
   * descriptions.
   * @param schemas An object where each key is a name and each value is a description
   * @returns A new instance of StructuredOutputParser.
   */
  static fromNamesAndDescriptions(schemas) {
    const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));
    return new this(zodSchema);
  }
  /**
   * Returns a markdown code snippet with a JSON object formatted according
   * to the schema.
   * @param options Optional. The options for formatting the instructions
   * @returns A markdown code snippet with a JSON object formatted according to the schema.
   */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(zodToJsonSchema(this.schema))}
\`\`\`
`;
  }
  /**
   * Parses the given text according to the schema.
   * @param text The text to parse
   * @returns The parsed output.
   */
  async parse(text) {
    try {
      const json = text.includes("```") ? text.trim().split(/```(?:json)?/)[1] : text.trim();
      return await this.schema.parseAsync(JSON.parse(json));
    } catch (e) {
      throw new OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
    }
  }
};
var JsonMarkdownStructuredOutputParser = class extends StructuredOutputParser {
  static lc_name() {
    return "JsonMarkdownStructuredOutputParser";
  }
  getFormatInstructions(options) {
    const interpolationDepth = (options == null ? void 0 : options.interpolationDepth) ?? 1;
    if (interpolationDepth < 1) {
      throw new Error("f string interpolation depth must be at least 1");
    }
    return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction(zodToJsonSchema(this.schema)).replaceAll("{", "{".repeat(interpolationDepth)).replaceAll("}", "}".repeat(interpolationDepth))}
\`\`\``;
  }
  _schemaToInstruction(schemaInput, indent = 2) {
    const schema = schemaInput;
    if ("type" in schema) {
      let nullable = false;
      let type;
      if (Array.isArray(schema.type)) {
        const nullIdx = schema.type.findIndex((type2) => type2 === "null");
        if (nullIdx !== -1) {
          nullable = true;
          schema.type.splice(nullIdx, 1);
        }
        type = schema.type.join(" | ");
      } else {
        type = schema.type;
      }
      if (schema.type === "object" && schema.properties) {
        const description2 = schema.description ? ` // ${schema.description}` : "";
        const properties = Object.entries(schema.properties).map(([key, value]) => {
          var _a;
          const isOptional = ((_a = schema.required) == null ? void 0 : _a.includes(key)) ? "" : " (optional)";
          return `${" ".repeat(indent)}"${key}": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;
        }).join("\n");
        return `{
${properties}
${" ".repeat(indent - 2)}}${description2}`;
      }
      if (schema.type === "array" && schema.items) {
        const description2 = schema.description ? ` // ${schema.description}` : "";
        return `array[
${" ".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}
${" ".repeat(indent - 2)}] ${description2}`;
      }
      const isNullable = nullable ? " (nullable)" : "";
      const description = schema.description ? ` // ${schema.description}` : "";
      return `${type}${description}${isNullable}`;
    }
    if ("anyOf" in schema) {
      return schema.anyOf.map((s) => this._schemaToInstruction(s, indent)).join(`
${" ".repeat(indent - 2)}`);
    }
    throw new Error("unsupported schema type");
  }
  static fromZodSchema(schema) {
    return new this(schema);
  }
  static fromNamesAndDescriptions(schemas) {
    const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));
    return new this(zodSchema);
  }
};
var AsymmetricStructuredOutputParser = class extends BaseOutputParser {
  constructor({ inputSchema }) {
    super(...arguments);
    Object.defineProperty(this, "structuredInputParser", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);
  }
  async parse(text) {
    let parsedInput;
    try {
      parsedInput = await this.structuredInputParser.parse(text);
    } catch (e) {
      throw new OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
    }
    return this.outputProcessor(parsedInput);
  }
  getFormatInstructions() {
    return this.structuredInputParser.getFormatInstructions();
  }
};

// node_modules/langchain/dist/output_parsers/prompts.js
var NAIVE_FIX_TEMPLATE = `Instructions:
--------------
{instructions}
--------------
Completion:
--------------
{completion}
--------------

Above, the Completion did not satisfy the constraints given in the Instructions.
Error:
--------------
{error}
--------------

Please try again. Please only respond with an answer that satisfies the constraints laid out in the Instructions:`;
var NAIVE_FIX_PROMPT = PromptTemplate.fromTemplate(NAIVE_FIX_TEMPLATE);

// node_modules/langchain/dist/output_parsers/fix.js
function isLLMChain(x) {
  return x.prompt !== void 0 && x.llm !== void 0;
}
var OutputFixingParser = class _OutputFixingParser extends BaseOutputParser {
  static lc_name() {
    return "OutputFixingParser";
  }
  /**
   * Static method to create a new instance of OutputFixingParser using a
   * given language model, parser, and optional fields.
   * @param llm The language model to be used.
   * @param parser The parser to be used.
   * @param fields Optional fields which may contain a prompt.
   * @returns A new instance of OutputFixingParser.
   */
  static fromLLM(llm, parser, fields) {
    const prompt = (fields == null ? void 0 : fields.prompt) ?? NAIVE_FIX_PROMPT;
    const chain = new LLMChain({ llm, prompt });
    return new _OutputFixingParser({ parser, retryChain: chain });
  }
  constructor({ parser, retryChain }) {
    super(...arguments);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "fix"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "parser", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "retryChain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.parser = parser;
    this.retryChain = retryChain;
  }
  /**
   * Method to parse the completion using the parser. If the initial parsing
   * fails, it uses the retryChain to attempt to fix the output and retry
   * the parsing process.
   * @param completion The completion to be parsed.
   * @param callbacks Optional callbacks to be used during parsing.
   * @returns The parsed output.
   */
  async parse(completion, callbacks) {
    try {
      return await this.parser.parse(completion, callbacks);
    } catch (e) {
      if (e instanceof OutputParserException) {
        const retryInput = {
          instructions: this.parser.getFormatInstructions(),
          completion,
          error: e
        };
        if (isLLMChain(this.retryChain)) {
          const result = await this.retryChain.call(retryInput, callbacks);
          const newCompletion = result[this.retryChain.outputKey];
          return this.parser.parse(newCompletion, callbacks);
        } else {
          const result = await this.retryChain.invoke(retryInput, {
            callbacks
          });
          return result;
        }
      }
      throw e;
    }
  }
  /**
   * Method to get the format instructions for the parser.
   * @returns The format instructions for the parser.
   */
  getFormatInstructions() {
    return this.parser.getFormatInstructions();
  }
};

// node_modules/langchain/dist/output_parsers/combining.js
var CombiningOutputParser = class extends BaseOutputParser {
  static lc_name() {
    return "CombiningOutputParser";
  }
  constructor(fields, ...parsers) {
    if (parsers.length > 0 || !("parsers" in fields)) {
      fields = {
        parsers: [fields, ...parsers]
      };
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "combining"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "parsers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "outputDelimiter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "-----"
    });
    this.parsers = fields.parsers;
  }
  /**
   * Method to parse an input string using the parsers in the parsers array.
   * The parsed outputs are combined into a single object and returned.
   * @param input The input string to parse.
   * @param callbacks Optional Callbacks object.
   * @returns A Promise that resolves to a CombinedOutput object.
   */
  async parse(input, callbacks) {
    const inputs = input.trim().split(new RegExp(`${this.outputDelimiter}Output \\d+${this.outputDelimiter}`)).slice(1);
    const ret = {};
    for (const [i, p] of this.parsers.entries()) {
      let parsed;
      try {
        let extracted = inputs[i].includes("```") ? inputs[i].trim().split(/```/)[1] : inputs[i].trim();
        if (extracted.endsWith(this.outputDelimiter)) {
          extracted = extracted.slice(0, -this.outputDelimiter.length);
        }
        parsed = await p.parse(extracted, callbacks);
      } catch (e) {
        parsed = await p.parse(input.trim(), callbacks);
      }
      Object.assign(ret, parsed);
    }
    return ret;
  }
  /**
   * Method to get instructions on how to format the LLM output. The
   * instructions are based on the parsers array and the outputDelimiter.
   * @returns A string with format instructions.
   */
  getFormatInstructions() {
    return `${[
      `Return the following ${this.parsers.length} outputs, each formatted as described below. Include the delimiter characters "${this.outputDelimiter}" in your response:`,
      ...this.parsers.map((p, i) => `${this.outputDelimiter}Output ${i + 1}${this.outputDelimiter}
${p.getFormatInstructions().trim()}
${this.outputDelimiter}`)
    ].join("\n\n")}
`;
  }
};

// node_modules/langchain/dist/output_parsers/router.js
var RouterOutputParser = class extends JsonMarkdownStructuredOutputParser {
  constructor(schema, options) {
    super(schema);
    Object.defineProperty(this, "defaultDestination", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DEFAULT"
    });
    this.defaultDestination = (options == null ? void 0 : options.defaultDestination) ?? this.defaultDestination;
  }
  /**
   * Overrides the parse method from JsonMarkdownStructuredOutputParser.
   * This method takes a string as input, attempts to parse it, and returns
   * the parsed text. If the destination of the parsed text matches the
   * defaultDestination, the destination is set to null. If the parsing
   * fails, an OutputParserException is thrown.
   * @param text The text to be parsed.
   * @returns The parsed text as a Promise.
   */
  async parse(text) {
    var _a;
    try {
      const parsedText = await super.parse(text);
      if (((_a = parsedText.destination) == null ? void 0 : _a.toLowerCase()) === this.defaultDestination.toLowerCase()) {
        parsedText.destination = null;
      }
      return parsedText;
    } catch (e) {
      throw new OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
    }
  }
};

// node_modules/langchain/dist/output_parsers/openai_functions.js
var OutputFunctionsParser = class extends BaseLLMOutputParser {
  static lc_name() {
    return "OutputFunctionsParser";
  }
  constructor(config) {
    super();
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "openai_functions"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "argsOnly", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    this.argsOnly = (config == null ? void 0 : config.argsOnly) ?? this.argsOnly;
  }
  /**
   * Parses the output and returns a string representation of the function
   * call or its arguments.
   * @param generations The output of the LLM to parse.
   * @returns A string representation of the function call or its arguments.
   */
  async parseResult(generations) {
    if ("message" in generations[0]) {
      const gen = generations[0];
      const functionCall = gen.message.additional_kwargs.function_call;
      if (!functionCall) {
        throw new Error(`No function_call in message ${JSON.stringify(generations)}`);
      }
      if (!functionCall.arguments) {
        throw new Error(`No arguments in function_call ${JSON.stringify(generations)}`);
      }
      if (this.argsOnly) {
        return functionCall.arguments;
      }
      return JSON.stringify(functionCall);
    } else {
      throw new Error(`No message in generations ${JSON.stringify(generations)}`);
    }
  }
};
var JsonOutputFunctionsParser = class extends BaseCumulativeTransformOutputParser {
  static lc_name() {
    return "JsonOutputFunctionsParser";
  }
  constructor(config) {
    super(config);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "openai_functions"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "outputParser", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "argsOnly", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    this.argsOnly = (config == null ? void 0 : config.argsOnly) ?? this.argsOnly;
    this.outputParser = new OutputFunctionsParser(config);
  }
  _diff(prev, next) {
    if (!next) {
      return void 0;
    }
    const ops = compare(prev ?? {}, next);
    return ops;
  }
  async parsePartialResult(generations) {
    const generation = generations[0];
    if (!generation.message) {
      return void 0;
    }
    const { message } = generation;
    const functionCall = message.additional_kwargs.function_call;
    if (!functionCall) {
      return void 0;
    }
    if (this.argsOnly) {
      return parsePartialJson(functionCall.arguments);
    }
    return {
      ...functionCall,
      arguments: parsePartialJson(functionCall.arguments)
    };
  }
  /**
   * Parses the output and returns a JSON object. If `argsOnly` is true,
   * only the arguments of the function call are returned.
   * @param generations The output of the LLM to parse.
   * @returns A JSON object representation of the function call or its arguments.
   */
  async parseResult(generations) {
    const result = await this.outputParser.parseResult(generations);
    if (!result) {
      throw new Error(`No result from "OutputFunctionsParser" ${JSON.stringify(generations)}`);
    }
    return this.parse(result);
  }
  async parse(text) {
    const parsedResult = JSON.parse(text);
    if (this.argsOnly) {
      return parsedResult;
    }
    parsedResult.arguments = JSON.parse(parsedResult.arguments);
    return parsedResult;
  }
  getFormatInstructions() {
    return "";
  }
};
var JsonKeyOutputFunctionsParser = class extends BaseLLMOutputParser {
  static lc_name() {
    return "JsonKeyOutputFunctionsParser";
  }
  get lc_aliases() {
    return {
      attrName: "key_name"
    };
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "openai_functions"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "outputParser", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new JsonOutputFunctionsParser()
    });
    Object.defineProperty(this, "attrName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.attrName = fields.attrName;
  }
  /**
   * Parses the output and returns a specific attribute of the parsed JSON
   * object.
   * @param generations The output of the LLM to parse.
   * @returns The value of a specific attribute of the parsed JSON object.
   */
  async parseResult(generations) {
    const result = await this.outputParser.parseResult(generations);
    return result[this.attrName];
  }
};

// node_modules/langchain/dist/output_parsers/openai_tools.js
var JsonOutputToolsParser = class extends BaseLLMOutputParser {
  static lc_name() {
    return "JsonOutputToolsParser";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "returnId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "openai_tools"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    this.returnId = (fields == null ? void 0 : fields.returnId) ?? this.returnId;
  }
  /**
   * Parses the output and returns a JSON object. If `argsOnly` is true,
   * only the arguments of the function call are returned.
   * @param generations The output of the LLM to parse.
   * @returns A JSON object representation of the function call or its arguments.
   */
  async parseResult(generations) {
    const toolCalls = generations[0].message.additional_kwargs.tool_calls;
    if (!toolCalls) {
      throw new Error(`No tools_call in message ${JSON.stringify(generations)}`);
    }
    const clonedToolCalls = JSON.parse(JSON.stringify(toolCalls));
    const parsedToolCalls = [];
    for (const toolCall of clonedToolCalls) {
      if (toolCall.function !== void 0) {
        const parsedToolCall = {
          type: toolCall.function.name,
          args: JSON.parse(toolCall.function.arguments)
        };
        if (this.returnId) {
          parsedToolCall.id = toolCall.id;
        }
        Object.defineProperty(parsedToolCall, "name", {
          get() {
            return this.type;
          }
        });
        Object.defineProperty(parsedToolCall, "arguments", {
          get() {
            return this.args;
          }
        });
        parsedToolCalls.push(parsedToolCall);
      }
    }
    return parsedToolCalls;
  }
};
var JsonOutputKeyToolsParser = class extends BaseLLMOutputParser {
  static lc_name() {
    return "JsonOutputKeyToolsParser";
  }
  constructor(params) {
    super(params);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "openai_tools"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "returnId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "keyName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "returnSingle", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "initialParser", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.keyName = params.keyName;
    this.returnSingle = params.returnSingle ?? this.returnSingle;
    this.initialParser = new JsonOutputToolsParser(params);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async parseResult(generations) {
    const results = await this.initialParser.parseResult(generations);
    const matchingResults = results.filter((result) => result.type === this.keyName);
    let returnedValues = matchingResults;
    if (!this.returnId) {
      returnedValues = matchingResults.map((result) => result.args);
    }
    if (this.returnSingle) {
      return returnedValues[0];
    }
    return returnedValues;
  }
};

// node_modules/langchain/dist/output_parsers/http_response.js
var HttpResponseOutputParser = class extends BaseTransformOutputParser {
  static lc_name() {
    return "HttpResponseOutputParser";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parser"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "outputParser", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new StringOutputParser()
    });
    Object.defineProperty(this, "contentType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "text/plain"
    });
    this.outputParser = (fields == null ? void 0 : fields.outputParser) ?? this.outputParser;
    this.contentType = (fields == null ? void 0 : fields.contentType) ?? this.contentType;
  }
  async *_transform(inputGenerator) {
    for await (const chunk of this.outputParser._transform(inputGenerator)) {
      if (typeof chunk === "string") {
        yield this.parse(chunk);
      } else {
        yield this.parse(JSON.stringify(chunk));
      }
    }
    if (this.contentType === "text/event-stream") {
      const encoder = new TextEncoder();
      yield encoder.encode(`event: end

`);
    }
  }
  /**
   * Parses a string output from an LLM call. This method is meant to be
   * implemented by subclasses to define how a string output from an LLM
   * should be parsed.
   * @param text The string output from an LLM call.
   * @param callbacks Optional callbacks.
   * @returns A promise of the parsed output.
   */
  async parse(text) {
    const chunk = await this.outputParser.parse(text);
    const encoder = new TextEncoder();
    if (this.contentType === "text/event-stream") {
      return encoder.encode(`event: data
data: ${JSON.stringify(chunk)}

`);
    }
    let parsedChunk;
    if (typeof chunk === "string") {
      parsedChunk = chunk;
    } else {
      parsedChunk = JSON.stringify(chunk);
    }
    return encoder.encode(parsedChunk);
  }
  getFormatInstructions() {
    return "";
  }
};

// node_modules/langchain/dist/output_parsers/datetime.js
var DatetimeOutputParser = class extends BaseOutputParser {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "format", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "YYYY-MM-DDTHH:mm:ssZ"
    });
  }
  static lc_name() {
    return "DatetimeOutputParser";
  }
  /**
   * Parses the given text into a Date.
   * If the parsing fails, throws an OutputParserException.
   * @param text The text to parse.
   * @returns A date object.
   */
  async parse(text) {
    const parsedDate = new Date(text.trim());
    if (Number.isNaN(parsedDate.getTime())) {
      throw new OutputParserException(`Could not parse output: ${text}`, text);
    }
    return parsedDate;
  }
  /**
   * Provides instructions on the expected format of the response for the
   * CommaSeparatedListOutputParser.
   * @returns A string containing instructions on the expected format of the response.
   */
  getFormatInstructions() {
    return [
      `Your response should be a datetime string that matches the following pattern: "${this.format}".`,
      `Examples: 2011-10-05T14:48:00Z, 2019-01-01T00:00:00Z, 1932-04-21T04:42:23Z`,
      `Return ONLY this string, no other words!`
    ].join("\n\n");
  }
};
export {
  AsymmetricStructuredOutputParser,
  CombiningOutputParser,
  CommaSeparatedListOutputParser,
  CustomListOutputParser,
  DatetimeOutputParser,
  HttpResponseOutputParser,
  JsonKeyOutputFunctionsParser,
  JsonMarkdownStructuredOutputParser,
  JsonOutputFunctionsParser,
  JsonOutputKeyToolsParser,
  JsonOutputToolsParser,
  ListOutputParser,
  OutputFixingParser,
  OutputFunctionsParser,
  RegexParser,
  RouterOutputParser,
  StructuredOutputParser
};
//# sourceMappingURL=langchain_output_parsers.js.map
