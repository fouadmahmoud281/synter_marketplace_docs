{
  "version": 3,
  "sources": ["../../langchain/dist/output_parsers/regex.js", "../../langchain/dist/output_parsers/structured.js", "../../langchain/dist/output_parsers/prompts.js", "../../langchain/dist/output_parsers/fix.js", "../../langchain/dist/output_parsers/combining.js", "../../langchain/dist/output_parsers/router.js", "../../langchain/dist/output_parsers/openai_functions.js", "../../langchain/dist/output_parsers/openai_tools.js", "../../langchain/dist/output_parsers/http_response.js", "../../langchain/dist/output_parsers/datetime.js"],
  "sourcesContent": ["import { BaseOutputParser, OutputParserException, } from \"@langchain/core/output_parsers\";\n/**\n * Class to parse the output of an LLM call into a dictionary.\n * @augments BaseOutputParser\n */\nexport class RegexParser extends BaseOutputParser {\n    static lc_name() {\n        return \"RegexParser\";\n    }\n    get lc_attributes() {\n        return {\n            regex: this.lc_kwargs.regex,\n        };\n    }\n    constructor(fields, outputKeys, defaultOutputKey) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (typeof fields === \"string\" || fields instanceof RegExp) {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { regex: fields, outputKeys: outputKeys, defaultOutputKey };\n        }\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields.regex instanceof RegExp) {\n            // eslint-disable-next-line no-param-reassign\n            fields.regex = {\n                pattern: fields.regex.source,\n                flags: fields.regex.flags,\n            };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"regex\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"regex\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultOutputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.regex =\n            // eslint-disable-next-line no-nested-ternary\n            typeof fields.regex === \"string\"\n                ? new RegExp(fields.regex)\n                : \"pattern\" in fields.regex\n                    ? new RegExp(fields.regex.pattern, fields.regex.flags)\n                    : fields.regex;\n        this.outputKeys = fields.outputKeys;\n        this.defaultOutputKey = fields.defaultOutputKey;\n    }\n    _type() {\n        return \"regex_parser\";\n    }\n    /**\n     * Parses the given text using the regex pattern and returns a dictionary\n     * with the parsed output. If the regex pattern does not match the text\n     * and no defaultOutputKey is provided, throws an OutputParserException.\n     * @param text The text to be parsed.\n     * @returns A dictionary with the parsed output.\n     */\n    async parse(text) {\n        const match = text.match(this.regex);\n        if (match) {\n            return this.outputKeys.reduce((acc, key, index) => {\n                acc[key] = match[index + 1];\n                return acc;\n            }, {});\n        }\n        if (this.defaultOutputKey === undefined) {\n            throw new OutputParserException(`Could not parse output: ${text}`, text);\n        }\n        return this.outputKeys.reduce((acc, key) => {\n            acc[key] = key === this.defaultOutputKey ? text : \"\";\n            return acc;\n        }, {});\n    }\n    /**\n     * Returns a string with instructions on how the LLM output should be\n     * formatted to match the regex pattern.\n     * @returns A string with formatting instructions.\n     */\n    getFormatInstructions() {\n        return `Your response should match the following regex: ${this.regex}`;\n    }\n}\n", "import { z } from \"zod\";\nimport { zodToJsonSchema, } from \"zod-to-json-schema\";\nimport { BaseOutputParser, OutputParserException, } from \"@langchain/core/output_parsers\";\nexport class StructuredOutputParser extends BaseOutputParser {\n    static lc_name() {\n        return \"StructuredOutputParser\";\n    }\n    toJSON() {\n        return this.toJSONNotImplemented();\n    }\n    constructor(schema) {\n        super(schema);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: schema\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"structured\"]\n        });\n    }\n    /**\n     * Creates a new StructuredOutputParser from a Zod schema.\n     * @param schema The Zod schema which the output should match\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    /**\n     * Creates a new StructuredOutputParser from a set of names and\n     * descriptions.\n     * @param schemas An object where each key is a name and each value is a description\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));\n        return new this(zodSchema);\n    }\n    /**\n     * Returns a markdown code snippet with a JSON object formatted according\n     * to the schema.\n     * @param options Optional. The options for formatting the instructions\n     * @returns A markdown code snippet with a JSON object formatted according to the schema.\n     */\n    getFormatInstructions() {\n        return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(zodToJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n    }\n    /**\n     * Parses the given text according to the schema.\n     * @param text The text to parse\n     * @returns The parsed output.\n     */\n    async parse(text) {\n        try {\n            const json = text.includes(\"```\")\n                ? text.trim().split(/```(?:json)?/)[1]\n                : text.trim();\n            return await this.schema.parseAsync(JSON.parse(json));\n        }\n        catch (e) {\n            throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n    }\n}\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser extends StructuredOutputParser {\n    static lc_name() {\n        return \"JsonMarkdownStructuredOutputParser\";\n    }\n    getFormatInstructions(options) {\n        const interpolationDepth = options?.interpolationDepth ?? 1;\n        if (interpolationDepth < 1) {\n            throw new Error(\"f string interpolation depth must be at least 1\");\n        }\n        return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(zodToJsonSchema(this.schema))\n            .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n            .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n    }\n    _schemaToInstruction(schemaInput, indent = 2) {\n        const schema = schemaInput;\n        if (\"type\" in schema) {\n            let nullable = false;\n            let type;\n            if (Array.isArray(schema.type)) {\n                const nullIdx = schema.type.findIndex((type) => type === \"null\");\n                if (nullIdx !== -1) {\n                    nullable = true;\n                    schema.type.splice(nullIdx, 1);\n                }\n                type = schema.type.join(\" | \");\n            }\n            else {\n                type = schema.type;\n            }\n            if (schema.type === \"object\" && schema.properties) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                const properties = Object.entries(schema.properties)\n                    .map(([key, value]) => {\n                    const isOptional = schema.required?.includes(key)\n                        ? \"\"\n                        : \" (optional)\";\n                    return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;\n                })\n                    .join(\"\\n\");\n                return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n            }\n            if (schema.type === \"array\" && schema.items) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}\\n${\" \".repeat(indent - 2)}] ${description}`;\n            }\n            const isNullable = nullable ? \" (nullable)\" : \"\";\n            const description = schema.description ? ` // ${schema.description}` : \"\";\n            return `${type}${description}${isNullable}`;\n        }\n        if (\"anyOf\" in schema) {\n            return schema.anyOf\n                .map((s) => this._schemaToInstruction(s, indent))\n                .join(`\\n${\" \".repeat(indent - 2)}`);\n        }\n        throw new Error(\"unsupported schema type\");\n    }\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));\n        return new this(zodSchema);\n    }\n}\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport class AsymmetricStructuredOutputParser extends BaseOutputParser {\n    constructor({ inputSchema }) {\n        super(...arguments);\n        Object.defineProperty(this, \"structuredInputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);\n    }\n    async parse(text) {\n        let parsedInput;\n        try {\n            parsedInput = await this.structuredInputParser.parse(text);\n        }\n        catch (e) {\n            throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n        return this.outputProcessor(parsedInput);\n    }\n    getFormatInstructions() {\n        return this.structuredInputParser.getFormatInstructions();\n    }\n}\n", "import { PromptTemplate } from \"@langchain/core/prompts\";\nexport const NAIVE_FIX_TEMPLATE = `Instructions:\n--------------\n{instructions}\n--------------\nCompletion:\n--------------\n{completion}\n--------------\n\nAbove, the Completion did not satisfy the constraints given in the Instructions.\nError:\n--------------\n{error}\n--------------\n\nPlease try again. Please only respond with an answer that satisfies the constraints laid out in the Instructions:`;\nexport const NAIVE_FIX_PROMPT = \n/* #__PURE__ */ PromptTemplate.fromTemplate(NAIVE_FIX_TEMPLATE);\n", "import { BaseOutputParser, OutputParserException, } from \"@langchain/core/output_parsers\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\nimport { NAIVE_FIX_PROMPT } from \"./prompts.js\";\nfunction isLLMChain(x) {\n    return (x.prompt !== undefined && x.llm !== undefined);\n}\n/**\n * Class that extends the BaseOutputParser to handle situations where the\n * initial parsing attempt fails. It contains a retryChain for retrying\n * the parsing process in case of a failure.\n */\nexport class OutputFixingParser extends BaseOutputParser {\n    static lc_name() {\n        return \"OutputFixingParser\";\n    }\n    /**\n     * Static method to create a new instance of OutputFixingParser using a\n     * given language model, parser, and optional fields.\n     * @param llm The language model to be used.\n     * @param parser The parser to be used.\n     * @param fields Optional fields which may contain a prompt.\n     * @returns A new instance of OutputFixingParser.\n     */\n    static fromLLM(llm, parser, fields) {\n        const prompt = fields?.prompt ?? NAIVE_FIX_PROMPT;\n        const chain = new LLMChain({ llm, prompt });\n        return new OutputFixingParser({ parser, retryChain: chain });\n    }\n    constructor({ parser, retryChain, }) {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"fix\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"parser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retryChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.parser = parser;\n        this.retryChain = retryChain;\n    }\n    /**\n     * Method to parse the completion using the parser. If the initial parsing\n     * fails, it uses the retryChain to attempt to fix the output and retry\n     * the parsing process.\n     * @param completion The completion to be parsed.\n     * @param callbacks Optional callbacks to be used during parsing.\n     * @returns The parsed output.\n     */\n    async parse(completion, callbacks) {\n        try {\n            return await this.parser.parse(completion, callbacks);\n        }\n        catch (e) {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (e instanceof OutputParserException) {\n                const retryInput = {\n                    instructions: this.parser.getFormatInstructions(),\n                    completion,\n                    error: e,\n                };\n                if (isLLMChain(this.retryChain)) {\n                    const result = await this.retryChain.call(retryInput, callbacks);\n                    const newCompletion = result[this.retryChain.outputKey];\n                    return this.parser.parse(newCompletion, callbacks);\n                }\n                else {\n                    const result = await this.retryChain.invoke(retryInput, {\n                        callbacks,\n                    });\n                    return result;\n                }\n            }\n            throw e;\n        }\n    }\n    /**\n     * Method to get the format instructions for the parser.\n     * @returns The format instructions for the parser.\n     */\n    getFormatInstructions() {\n        return this.parser.getFormatInstructions();\n    }\n}\n", "import { BaseOutputParser } from \"@langchain/core/output_parsers\";\n/**\n * Class to combine multiple output parsers\n * @augments BaseOutputParser\n */\nexport class CombiningOutputParser extends BaseOutputParser {\n    static lc_name() {\n        return \"CombiningOutputParser\";\n    }\n    constructor(fields, ...parsers) {\n        if (parsers.length > 0 || !(\"parsers\" in fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = {\n                parsers: [fields, ...parsers],\n            };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"combining\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"parsers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputDelimiter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"-----\"\n        });\n        this.parsers = fields.parsers;\n    }\n    /**\n     * Method to parse an input string using the parsers in the parsers array.\n     * The parsed outputs are combined into a single object and returned.\n     * @param input The input string to parse.\n     * @param callbacks Optional Callbacks object.\n     * @returns A Promise that resolves to a CombinedOutput object.\n     */\n    async parse(input, callbacks) {\n        const inputs = input\n            .trim()\n            .split(new RegExp(`${this.outputDelimiter}Output \\\\d+${this.outputDelimiter}`))\n            .slice(1);\n        const ret = {};\n        for (const [i, p] of this.parsers.entries()) {\n            let parsed;\n            try {\n                let extracted = inputs[i].includes(\"```\")\n                    ? inputs[i].trim().split(/```/)[1]\n                    : inputs[i].trim();\n                if (extracted.endsWith(this.outputDelimiter)) {\n                    extracted = extracted.slice(0, -this.outputDelimiter.length);\n                }\n                parsed = await p.parse(extracted, callbacks);\n            }\n            catch (e) {\n                parsed = await p.parse(input.trim(), callbacks);\n            }\n            Object.assign(ret, parsed);\n        }\n        return ret;\n    }\n    /**\n     * Method to get instructions on how to format the LLM output. The\n     * instructions are based on the parsers array and the outputDelimiter.\n     * @returns A string with format instructions.\n     */\n    getFormatInstructions() {\n        return `${[\n            `Return the following ${this.parsers.length} outputs, each formatted as described below. Include the delimiter characters \"${this.outputDelimiter}\" in your response:`,\n            ...this.parsers.map((p, i) => `${this.outputDelimiter}Output ${i + 1}${this.outputDelimiter}\\n${p\n                .getFormatInstructions()\n                .trim()}\\n${this.outputDelimiter}`),\n        ].join(\"\\n\\n\")}\\n`;\n    }\n}\n", "import { OutputParserException } from \"@langchain/core/output_parsers\";\nimport { JsonMarkdownStructuredOutputParser } from \"./structured.js\";\n/**\n * A type of output parser that extends the\n * JsonMarkdownStructuredOutputParser. It is used to parse the output of a\n * router in LangChain. The class takes a schema and an optional\n * RouterOutputParserInput object as parameters.\n */\nexport class RouterOutputParser extends JsonMarkdownStructuredOutputParser {\n    constructor(schema, options) {\n        super(schema);\n        Object.defineProperty(this, \"defaultDestination\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"DEFAULT\"\n        });\n        this.defaultDestination =\n            options?.defaultDestination ?? this.defaultDestination;\n    }\n    /**\n     * Overrides the parse method from JsonMarkdownStructuredOutputParser.\n     * This method takes a string as input, attempts to parse it, and returns\n     * the parsed text. If the destination of the parsed text matches the\n     * defaultDestination, the destination is set to null. If the parsing\n     * fails, an OutputParserException is thrown.\n     * @param text The text to be parsed.\n     * @returns The parsed text as a Promise.\n     */\n    async parse(text) {\n        try {\n            const parsedText = await super.parse(text);\n            if (parsedText.destination?.toLowerCase() ===\n                this.defaultDestination.toLowerCase()) {\n                parsedText.destination = null;\n            }\n            return parsedText;\n        }\n        catch (e) {\n            throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n    }\n}\n", "import { compare, } from \"@langchain/core/utils/json_patch\";\nimport { BaseCumulativeTransformOutputParser, BaseLLMOutputParser, } from \"@langchain/core/output_parsers\";\nimport { parsePartialJson } from \"@langchain/core/output_parsers\";\n/**\n * Class for parsing the output of an LLM. Can be configured to return\n * only the arguments of the function call in the output.\n */\nexport class OutputFunctionsParser extends BaseLLMOutputParser {\n    static lc_name() {\n        return \"OutputFunctionsParser\";\n    }\n    constructor(config) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"argsOnly\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.argsOnly = config?.argsOnly ?? this.argsOnly;\n    }\n    /**\n     * Parses the output and returns a string representation of the function\n     * call or its arguments.\n     * @param generations The output of the LLM to parse.\n     * @returns A string representation of the function call or its arguments.\n     */\n    async parseResult(generations) {\n        if (\"message\" in generations[0]) {\n            const gen = generations[0];\n            const functionCall = gen.message.additional_kwargs.function_call;\n            if (!functionCall) {\n                throw new Error(`No function_call in message ${JSON.stringify(generations)}`);\n            }\n            if (!functionCall.arguments) {\n                throw new Error(`No arguments in function_call ${JSON.stringify(generations)}`);\n            }\n            if (this.argsOnly) {\n                return functionCall.arguments;\n            }\n            return JSON.stringify(functionCall);\n        }\n        else {\n            throw new Error(`No message in generations ${JSON.stringify(generations)}`);\n        }\n    }\n}\n/**\n * Class for parsing the output of an LLM into a JSON object. Uses an\n * instance of `OutputFunctionsParser` to parse the output.\n */\nexport class JsonOutputFunctionsParser extends BaseCumulativeTransformOutputParser {\n    static lc_name() {\n        return \"JsonOutputFunctionsParser\";\n    }\n    constructor(config) {\n        super(config);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argsOnly\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.argsOnly = config?.argsOnly ?? this.argsOnly;\n        this.outputParser = new OutputFunctionsParser(config);\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        const ops = compare(prev ?? {}, next);\n        return ops;\n    }\n    async parsePartialResult(generations) {\n        const generation = generations[0];\n        if (!generation.message) {\n            return undefined;\n        }\n        const { message } = generation;\n        const functionCall = message.additional_kwargs.function_call;\n        if (!functionCall) {\n            return undefined;\n        }\n        if (this.argsOnly) {\n            return parsePartialJson(functionCall.arguments);\n        }\n        return {\n            ...functionCall,\n            arguments: parsePartialJson(functionCall.arguments),\n        };\n    }\n    /**\n     * Parses the output and returns a JSON object. If `argsOnly` is true,\n     * only the arguments of the function call are returned.\n     * @param generations The output of the LLM to parse.\n     * @returns A JSON object representation of the function call or its arguments.\n     */\n    async parseResult(generations) {\n        const result = await this.outputParser.parseResult(generations);\n        if (!result) {\n            throw new Error(`No result from \"OutputFunctionsParser\" ${JSON.stringify(generations)}`);\n        }\n        return this.parse(result);\n    }\n    async parse(text) {\n        const parsedResult = JSON.parse(text);\n        if (this.argsOnly) {\n            return parsedResult;\n        }\n        parsedResult.arguments = JSON.parse(parsedResult.arguments);\n        return parsedResult;\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n/**\n * Class for parsing the output of an LLM into a JSON object and returning\n * a specific attribute. Uses an instance of `JsonOutputFunctionsParser`\n * to parse the output.\n */\nexport class JsonKeyOutputFunctionsParser extends BaseLLMOutputParser {\n    static lc_name() {\n        return \"JsonKeyOutputFunctionsParser\";\n    }\n    get lc_aliases() {\n        return {\n            attrName: \"key_name\",\n        };\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new JsonOutputFunctionsParser()\n        });\n        Object.defineProperty(this, \"attrName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.attrName = fields.attrName;\n    }\n    /**\n     * Parses the output and returns a specific attribute of the parsed JSON\n     * object.\n     * @param generations The output of the LLM to parse.\n     * @returns The value of a specific attribute of the parsed JSON object.\n     */\n    async parseResult(generations) {\n        const result = await this.outputParser.parseResult(generations);\n        return result[this.attrName];\n    }\n}\n", "import { BaseLLMOutputParser } from \"@langchain/core/output_parsers\";\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser extends BaseLLMOutputParser {\n    static lc_name() {\n        return \"JsonOutputToolsParser\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.returnId = fields?.returnId ?? this.returnId;\n    }\n    /**\n     * Parses the output and returns a JSON object. If `argsOnly` is true,\n     * only the arguments of the function call are returned.\n     * @param generations The output of the LLM to parse.\n     * @returns A JSON object representation of the function call or its arguments.\n     */\n    async parseResult(generations) {\n        const toolCalls = generations[0].message.additional_kwargs.tool_calls;\n        if (!toolCalls) {\n            throw new Error(`No tools_call in message ${JSON.stringify(generations)}`);\n        }\n        const clonedToolCalls = JSON.parse(JSON.stringify(toolCalls));\n        const parsedToolCalls = [];\n        for (const toolCall of clonedToolCalls) {\n            if (toolCall.function !== undefined) {\n                // @ts-expect-error name and arguemnts are defined by Object.defineProperty\n                const parsedToolCall = {\n                    type: toolCall.function.name,\n                    args: JSON.parse(toolCall.function.arguments),\n                };\n                if (this.returnId) {\n                    parsedToolCall.id = toolCall.id;\n                }\n                // backward-compatibility with previous\n                // versions of Langchain JS, which uses `name` and `arguments`\n                Object.defineProperty(parsedToolCall, \"name\", {\n                    get() {\n                        return this.type;\n                    },\n                });\n                Object.defineProperty(parsedToolCall, \"arguments\", {\n                    get() {\n                        return this.args;\n                    },\n                });\n                parsedToolCalls.push(parsedToolCall);\n            }\n        }\n        return parsedToolCalls;\n    }\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class JsonOutputKeyToolsParser extends BaseLLMOutputParser {\n    static lc_name() {\n        return \"JsonOutputKeyToolsParser\";\n    }\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /** The type of tool calls to return. */\n        Object.defineProperty(this, \"keyName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to return only the first tool call. */\n        Object.defineProperty(this, \"returnSingle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"initialParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keyName = params.keyName;\n        this.returnSingle = params.returnSingle ?? this.returnSingle;\n        this.initialParser = new JsonOutputToolsParser(params);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parseResult(generations) {\n        const results = await this.initialParser.parseResult(generations);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return returnedValues[0];\n        }\n        return returnedValues;\n    }\n}\n", "import { BaseTransformOutputParser, StringOutputParser, } from \"@langchain/core/output_parsers\";\n/**\n * OutputParser that formats chunks emitted from an LLM for different HTTP content types.\n */\nexport class HttpResponseOutputParser extends BaseTransformOutputParser {\n    static lc_name() {\n        return \"HttpResponseOutputParser\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parser\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new StringOutputParser()\n        });\n        Object.defineProperty(this, \"contentType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"text/plain\"\n        });\n        this.outputParser = fields?.outputParser ?? this.outputParser;\n        this.contentType = fields?.contentType ?? this.contentType;\n    }\n    async *_transform(inputGenerator) {\n        for await (const chunk of this.outputParser._transform(inputGenerator)) {\n            if (typeof chunk === \"string\") {\n                yield this.parse(chunk);\n            }\n            else {\n                yield this.parse(JSON.stringify(chunk));\n            }\n        }\n        if (this.contentType === \"text/event-stream\") {\n            const encoder = new TextEncoder();\n            yield encoder.encode(`event: end\\n\\n`);\n        }\n    }\n    /**\n     * Parses a string output from an LLM call. This method is meant to be\n     * implemented by subclasses to define how a string output from an LLM\n     * should be parsed.\n     * @param text The string output from an LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    async parse(text) {\n        const chunk = await this.outputParser.parse(text);\n        const encoder = new TextEncoder();\n        if (this.contentType === \"text/event-stream\") {\n            return encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`);\n        }\n        let parsedChunk;\n        if (typeof chunk === \"string\") {\n            parsedChunk = chunk;\n        }\n        else {\n            parsedChunk = JSON.stringify(chunk);\n        }\n        return encoder.encode(parsedChunk);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n", "import { BaseOutputParser, OutputParserException, } from \"@langchain/core/output_parsers\";\n/**\n * Class to parse the output of an LLM call to a date.\n * @augments BaseOutputParser\n */\nexport class DatetimeOutputParser extends BaseOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * ISO 8601 date time standard.\n         */\n        Object.defineProperty(this, \"format\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"YYYY-MM-DDTHH:mm:ssZ\"\n        });\n    }\n    static lc_name() {\n        return \"DatetimeOutputParser\";\n    }\n    /**\n     * Parses the given text into a Date.\n     * If the parsing fails, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns A date object.\n     */\n    async parse(text) {\n        const parsedDate = new Date(text.trim());\n        if (Number.isNaN(parsedDate.getTime())) {\n            throw new OutputParserException(`Could not parse output: ${text}`, text);\n        }\n        return parsedDate;\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CommaSeparatedListOutputParser.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return [\n            `Your response should be a datetime string that matches the following pattern: \"${this.format}\".`,\n            `Examples: 2011-10-05T14:48:00Z, 2019-01-01T00:00:00Z, 1932-04-21T04:42:23Z`,\n            `Return ONLY this string, no other words!`,\n        ].join(\"\\n\\n\");\n    }\n}\n"],
  "mappings": "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",
  "names": ["type", "description"]
}
